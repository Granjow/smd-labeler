import fs from 'fs';
import { Symbol } from './symbol';
import { Table } from './table';
import path from 'path';

const symbols: Symbol[] = [
    new Symbol( 'C' ),
    new Symbol( 'D-Si' ),
    new Symbol( 'D-Sc' ),
    new Symbol( 'FET-N' ),
    new Symbol( 'FET-P' ),
    new Symbol( 'LED' ),
    new Symbol( 'R' ),
    new Symbol( 'IC' ),
];

export interface SmdLabelerArgs {
    pageWidth?: number;
    pageHeight?: number;
    labelWidth?: number;
    labelHeight?: number;
}

/**
 * Generates printable labels, e.g. for SMD parts.
 */
export class SmdLabeler {

    public static readonly startMarker = 'START_MARKER';

    public readonly pageWidth: number;
    public readonly pageHeight: number;
    public readonly labelWidth: number;
    public readonly labelHeight: number;

    private readonly mainTemplate: string;
    private readonly smallTemplate: string;
    private readonly horizontalTickTemplate: string;
    private readonly verticalTickTemplate: string;

    constructor( args?: SmdLabelerArgs ) {
        this.pageWidth = args?.pageWidth ?? 210;
        this.pageHeight = args?.pageHeight ?? 297;
        this.labelWidth = args?.labelWidth ?? 16;
        this.labelHeight = args?.labelHeight ?? 13;

        this.mainTemplate = fs.readFileSync( path.join( __dirname, '../..', 'templates/TemplateMain.svg' ), {
            encoding: 'utf8',
            flag: 'r'
        } );
        this.smallTemplate = fs.readFileSync( path.join( __dirname, '../..', 'templates/TemplateSmallLabel.svg' ), {
            encoding: 'utf8',
            flag: 'r'
        } );
        this.horizontalTickTemplate = fs.readFileSync( path.join( __dirname, '../..', 'templates/TemplateHorizontalCutMark.svg' ), {
            encoding: 'utf8',
            flag: 'r'
        } );
        this.verticalTickTemplate = fs.readFileSync( path.join( __dirname, '../..', 'templates/TemplateVerticalCutMark.svg' ), {
            encoding: 'utf8',
            flag: 'r'
        } );
    }

    /**
     * Generate the raw SVG labels from the input data.
     * @param data Array of entries, each containing text to put on a label. The text follows a certain format
     * and should be generated by one of the Sym.* functions as this will add component symbols to the label.
     * One special entry is the SmdLabeler.startMarker which causes all previous entries to be ignored;
     * this allows to maintain a parts list and continuously add parts without removing previous ones.
     */
    generateLabels( data: string[] ): string[] {
        const labels = [];
        const border = 20;
        const w = this.pageWidth - ( 2 * border ) - ( ( this.pageWidth - ( 2 * border ) ) % this.labelWidth );
        const h = this.pageHeight - ( 2 * border ) - ( ( this.pageHeight - ( 2 * border ) ) % this.labelHeight );
        const table = new Table( ( this.pageWidth - w ) / 2, ( this.pageHeight - h ) / 2, this.labelWidth, this.labelHeight, w, h );

        const startIndex = data.indexOf( SmdLabeler.startMarker );

        for ( const line of data.slice( startIndex + 1 ) ) {
            const label = this.entry( line, table.x, table.y );
            table.next();
            labels.push( label );
        }

        for ( let r = 0; r <= table.rows; r++ ) {
            const y = table.y0 + r * table.dy;
            labels.push( this.horizontalCut( table.x0 - 1, y ) );
            labels.push( this.horizontalCut( table.x0 + ( table.cols * table.dx ), y ) );
        }

        for ( let c = 0; c <= table.cols; c++ ) {
            const x = table.x0 + c * table.dx;
            labels.push( this.verticalCut( x, table.y0 - 1 ) );
            labels.push( this.verticalCut( x, table.y0 + ( table.rows * table.dy ) ) );
        }

        return labels;
    }

    generateSvg( data: string[] ): string {
        return this.assembleSvg( this.generateLabels( data ) );
    }

    saveSvg( data: string[], filePath: string ): void {
        fs.writeFileSync( filePath, this.generateSvg( data ) );
    }


    private entry( text: string, x: number, y: number ): string {
        let labelSymbol = '';
        for ( const symbol of symbols ) {
            if ( symbol.applies( text ) ) {
                labelSymbol = symbol.templateAt( this.labelWidth - 3, this.labelHeight - 3 );
                text = symbol.adjustText( text );
            }
        }
        const lines = text.split( '\n' );
        return this.smallTemplate
            .replace( 'LINE1', lines[ 0 ] || ' ' )
            .replace( 'LINE2', lines[ 1 ] || ' ' )
            .replace( 'LINE3', lines[ 2 ] || ' ' )
            .replace( 'LINE4', lines[ 3 ] || ' ' )
            .replace( '<g', `<g transform="translate(${x}, ${y})"` )
            .replace( '<text', `'${labelSymbol}\n<text` );
    }

    private horizontalCut( x: number, y: number ): string {
        return this.horizontalTickTemplate
            .replace( 'id="horizontalCutMark"', `transform="translate(${x}, ${y})"` );
    }

    private verticalCut( x: number, y: number ): string {
        return this.verticalTickTemplate
            .replace( 'id="verticalCutMark"', `transform="translate(${x}, ${y})"` );
    }

    private assembleSvg( labels: string[] ): string {
        return this.mainTemplate.replace( '</g>', labels.join( '\n' ) + '</g>' );
    }

}
